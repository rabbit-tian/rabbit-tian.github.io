### 提高页面性能的方法有哪些
1. 资源压缩合并，减少HTTP请求
2. 非核心代码异步加载
    - 异步加载的方式有哪些
        - 动态脚本加载（js创建script标签，再加到body中去）
        - defer：在script标签上加上这个属性
        - async：在script标签上加上这个属性
    - 异步加载方式的区别
        - defer是在HTML解析后才会执行，如果是多个，按照加载的顺序依次执行  
        - async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关

3. 利用浏览器缓存：基本的
    - 缓存的分类
        - 强缓存：在此时间前，不和服务器通信，直接拿来用
            - 绝对时间（下发服务器时间）
            - 客户端相对时间3600s(为准)
        - 协商缓存：浏览器和服务器协商该缓存是否可用，当强缓存失效，浏览器会携带上次的时间去对比
    - 缓存的原理
    - 和缓存相关的http协议头
        - Expires
        - Cache-Control
        - Last-Modified
        - If-Modefied--Since
        - Etage
        - If-None-Match
4. 使用CDN
    - 让网络快速到达服务端，把文件下载下来（特别在第一次打开页面时）
5. 预解析DNS
    - `<link rel="dns-prefetch" href="//host_name_to_prefetch.com">`
    - 强制打开a标签的预解析(https协议中，a标签预解析关闭)：`<meta http-equiv="x-dns-prefetch-control" content="on">`

6. 硬件加速：用显卡的GPU解码，分担了CPU的解码工作


### 慕课网课程学习 web前端性能优化

1. 资源的合并与压缩
    (减少http请求的数量,减少请求资源的大小)
    - html 代码压缩：对空格、制表符、换行符、html注释等的压缩，并进行gzip压缩
        - nodejs 提供的 HTML-minifier 工具：构建阶段和服务端压缩
        - 后端模板引擎渲染压缩

    - css 代码压缩： 无效代码删除，去空格，代码合并
        - HTML-minifier 工具
        - 使用 clean-css 对css进行压缩

    - js 代码压缩： 无效字符删除，代码缩减优化，输出注释，代码保护
        - HTML-minifier 工具
        
    - 文件合并： 使用 node.js 实现文件合并
        - 首屏渲染问题
        - 缓存失效问题
    

2. 图片的优化
    - 图片压缩方法
        - css sprite 雪碧图
            - 优点：减少http请求数量
            - 缺点：整合图片大，一次加载慢
        - Image inline
            - base 64 格式,减少网站的http请求
        - 使用svg矢量图
            - 使用 iconfont 字体图标 
        - 安卓下的 webp：体积小，性能好

    - jpg: 有损压缩，压缩率高，不支持透明
    - png：支持透明，浏览器兼容好
    - webp: 压缩程度更好，有兼容问题，应用 安卓
    - svg矢量图：代码内嵌，相对较小，应用于图片样式相对简单场景

3. css,js 加载过程中的优化点
    - 浏览器的渲染过程 dom Tree cssom tree render tree layout paint
    - css 阻塞 js 的执行，不阻塞外部脚本的加载
    - 依赖关系
        - 页面渲染依赖于css加载
        - js执行顺序的依赖关系
        - js逻辑对于dom节点的依赖关系(dom节点已生成)
    - js 的引入方式 的优化
        - 直接引入：阻塞页面的渲染
        - defer：不要让js阻塞页面渲染，执行时间到dom树完成之后
        - async：不要让js阻塞页面渲染，不保证脚本执行的顺序，脚本顺序之间不能有依赖关系
        - 异步动态引入js

    - 加载和执行的一些优化点
        - css 样式表置顶
            - 放在head中，会阻塞页面的渲染，保证在没有css的情况下不会渲染出来没有样式的html结构，体验不好
        - link 代替 import
            - import：把css放在dom结构最底端，同时没有进行并发的操作，性能不好
        - js 脚本置底部
            - 对于页面渲染，最基本的页面元素样式不依赖与js，依赖于 html 和 css
        - 合理使用js的异步加载能力
    
4. 懒加载和预加载
    - 懒加载
        - 图片进入可视区域之后请求图片资源，将属性url上的地址设置给img的src
        - 对于电商等图片很多，用户可能不会访问那么多图谱，减少无效资源的加载
        - 并发加载的资源过多会阻塞js的加载，影响网站的正常使用
    
    - 预加载
        - 图片等静态资源在使用之前的提前请求
        - 资源使用到时从缓存中加载，提升用户性能
        - 方式：
            - img 标签加 行间样式 设置dispaly: none
            - 使用image 对象，先下载 图片资源
            - 使用xmlhttprequest对象，存在跨域问题
            - 使用preload库
            
 5. 减少回流和重绘
    - 回流：元素布局，尺寸的变化，需要重新构建
        - 盒子模型
        - 定位属性
        - 节点内部文字结构
    
    - 重绘：只是外观，风格改变，不影响布局 
        - color，bgc等
    
    - 回流一定会引起重绘，重绘不一定会引起回流
    - 优化点
        - 避免触发重绘，回流
        - 频繁回流重绘的dom元素 放在一个独立的图层上，图层也会消耗性能
            - 创造图层的条件
                - 3D
                - 使用加速视频解码的`<video>`节点
                - css动画
        
5. 浏览器存储
    - cookie
        - 因为 http 请求是无状态的，所以需要cookie去维护客户端的状态，登录信息储存在cookie中
        - 用于浏览器和服务端的交互
        - 作为浏览器储存，大小4kb左右
        - 需要设置过期时间 expire
        - httponly,不允许js读写

    - localstorage
        - html5 专门设计出来由于浏览器储存的
        - 大小为 5 MB
        - 仅在客服端使用，不和服务端进行通信
        - 接口封装较好
        - 浏览器本地缓存的方案
            - 比如 进入这个商户后，第一次进入一个商户 ，向服务端请求很多数据，可能包括商户信息，商品产品，logo之类等不会改变，所以没有必要直接向服务端读取这个数据，我们可以直接把首屏上的商户信息等直接通过localstorage读取出来，渲染出来，这样快很多，不会有首屏白屏时间，如果后续有数据返回之后，重新渲染再一次，把老的本地缓存中数据替换掉，这样对用户不会有太大损失
        
    - sessionstorage
        - 和localstorage位移区别就是：会话级别的浏览器储存,浏览器的一个tab就是一个会话，tab中储存在 sessionstorage 中数据，可以在tab中使用
        - 应用：表单信息维护，填写很多用户信息，在不小心情况下，页面刷新了，信息需要重新填写，这样的体验不好，我们能在会话维度维护相关的表单信息的不丢失，把表单信息储存在sessionstorage，就算用户刷新了这个页面，也能从sessionstorage中把相关信息提取出来，当关闭页面，再打开表单页面时，sessionstorage 中的是空的
       
    - indexDB
        - 储存客户端大量的结构化的数据
        - 为应用创建离线版本
    
    - pwa 和 server worker 的应用
        - server worker ：原来js是单线程的，在用户层面没法创造多个线程，大数量读取和运算会影响相关页面渲染，用server worker，在其他线程中进行大规模数量读取和运算，将结果返回到主线程，然后由主线程 执行渲染，这样可以避免主线程代码被 巨大的js逻辑阻塞，大大提升浏览器在处理大规模js运算上的能力
        
        - pwa: 一种 web App 新模式，一些列新的web特性，配合优秀的 UI 交互设计，逐步增强的 web app 的用户体验
            - 可靠性：没网络情况下的基本页面访问
            - 快速性：网页渲染和数据访问有较好优化
            - 融入： 应用可以被增加到手机桌面，和普通应用一样有全屏，推送等特性


6. 缓存
    - cache-control: 客服端和服务端协商的缓存策略
        - max-age: 状态 200，浏览器缓存的时间，在这个时间内，浏览器请求资源不会向服务端发请求，会从缓存中直接读(max-age 比 expires 优先级高)
        - s-maxage: 状态 304，在public缓存的区域读取相关的缓存信息，从 CDN 上拿
        - no-cache: 发请求到服务端判断浏览器的缓存有没有过期
        - no-store: 不使用缓策略
    
    - last-modified / if-modified-since
        - 客服端和服务端协商的缓存机制
        - 感知到服务端的文件发生变化
        - 304：服务端没对文件作出更新
        - 200：文件更新了，发了一份新的文件来

    
7. 服务端性能优化
    - vue层面上的性能优化
        - 构建层的模板编译
        - 数据无关的 prerender 的方式（预渲染）
        - 服务端渲染

