### 排序 ***
1. 快速排序  http://segmentfault.com/a/1190000009426421

   ```js
   var quickSort = function(arr) {
       if (arr.length <= 1) { return arr; }
       var pivotIndex = Math.floor(arr.length / 2);   //基准位置（理论上可任意选取）
       var pivot = arr.splice(pivotIndex, 1)[0];  //基准数
       var left = [];
       var right = [];
       for (var i = 0; i < arr.length; i++){
           if (arr[i] < pivot) {
               left.push(arr[i]);
           } else {
               right.push(arr[i]);
           }
       }
       return quickSort(left).concat([pivot], quickSort(right));  //链接左数组、基准数构成的数组、右数组
   };
   
   ```

   

2. 选择排序  http://segmentfault.com/a/1190000009366805

   ```js
   function selectionSort(arr) {
       var len = arr.length;
       var minIndex, temp;
       for (var i = 0; i < len - 1; i++) {
           minIndex = i;
           for (var j = i + 1; j < len; j++) {
               if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                   minIndex = j;                 // 将最小数的索引保存
               }
           }
           temp = arr[i];
           arr[i] = arr[minIndex];
           arr[minIndex] = temp;
       }
       return arr;
   }
   
   ```

   

3. 希尔排序(递减增量排序算法)  http://segmentfault.com/a/1190000009461832

   ```js
   function shellSort(arr) {
       var len = arr.length,
           temp,
           gap = 1;
       while(gap < len/3) {          //动态定义间隔序列
           gap = gap*3+1;
       }
       for (gap; gap > 0; gap = Math.floor(gap/3)) {
           for (var i = gap; i < len; i++) {
               temp = arr[i];
               for (var j = i-gap; j >= 0 && arr[j] > temp; j -= gap) {
                   arr[j+gap] = arr[j];
               }
               arr[j+gap] = temp;
           }
       }
       return arr;
   }
   
   ```

   

4. 冒泡排序

### 堆栈***，队列，链表
1.  http://juejin.im/entry/58759e79128fe1006b48cdfd

### 递归***
1. http://segmentfault.com/a/1190000009857470
