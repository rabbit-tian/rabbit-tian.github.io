1. 事件委托原理
    - 事件是会冒泡的，我们在父节点上面监听事件，当事件冒泡上来的时候，我们再捕获他，然后进行事件处理

2. 闭包
    - 将变量变成私有变量，然后暴露一个借口由于外界通信，从而避免对全局的命名污染
    - 代码展示
    
    ```
    function closure() {
        let n = 1;
        return function() {
            n++
            console.log(n)
        }
    }
    let outer = closure()
    outer(); // 2
    outer(); // 3
    ```

3. jsonp 跨域
    - http的同源策略，ajax不能进行跨域请求
    - 我们前端利用script本身能跨域的这个特点，将src指向服务端数据的这个接口，并且定义一个函数来接收服务端返回的数据，这个函数名是双方协商好的，服务端接收到这个请求后，用这个函数包裹所需的数据再返回给我们前端，前端执行这个函数就可以拿到数据

4. ajax手写四部曲
    
    ```
    let xhr = new XMLHttpReauest();
    xhr.open('GET','/xxx);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
            console.log(xhr.responseText)
        }
    }
    xhr.send('a=1&b=2')
    ```
5. promise
    - jquery 的调用
    
    ```
    $.ajax().then(成功函数，失败函数)
    ```
    
    - 自己实现 
        
    ```
    function hand() {
        return new Promise (function (resolve,reject) {
            setTimeout(function () {
                resolve()或者 reject()
            })
        })
    }
    // 异步代码操作
    hand().then()
    
    // 异步代码变同步代码
    async function asyncCall() {
        let result = await hand()
    }
    asyncCall()
    ```
6. 深拷贝
    - json ：json.parse(json.stringify(a)),但不支持函数等形式
    - 递归 结合 instanceof

7. 数组去重
    - if else 判断，只支持正整数
    - Set去重  Array.from(new Set(arr))

8. 如何用正则实现 string.trim()?
    
    ```
    function trim(str) {
        return str.replace(/^\s+|\s+$/,'')
    }
    ```

9. 性能优化
    - 函数节流：throttle函数，自动进行定时器的设置和清除
    - 


10. 模块化
    - cmd: 延迟执行，异步操作，先加载懒执行，就近依赖，只有在用到某个模块的时候再去引入模块
    - amd: 依赖前置，在定义模块的时候就要就要声明其依赖的模块

11. 

